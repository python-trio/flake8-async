# NOASYNCIO
# NOANYIO - don't run it with substitutions
import anyio
import trio
import asyncio
from asyncio.exceptions import CancelledError
from asyncio import exceptions

try:
    ...
except trio.Cancelled:  # ASYNC103: 7, "trio.Cancelled"
    ...
except (
    anyio.get_cancelled_exc_class()  # ASYNC103: 4, "anyio.get_cancelled_exc_class()"
):
    ...
except CancelledError:  # ASYNC103: 7, "CancelledError"
    ...
except:  # safe
    ...

# reordered
try:
    ...
except (
    asyncio.exceptions.CancelledError  # ASYNC103: 4, "asyncio.exceptions.CancelledError"
):
    ...
except (
    anyio.get_cancelled_exc_class()  # ASYNC103: 4, "anyio.get_cancelled_exc_class()"
):
    ...
except trio.Cancelled:  # ASYNC103: 7, "trio.Cancelled"
    ...
except:  # safe
    ...

# asyncio supports all three ways of importing asyncio.exceptions.CancelledError
try:
    ...
except exceptions.CancelledError:  # ASYNC103: 7, "exceptions.CancelledError"
    ...

# catching any one of the exceptions in multi-library files will suppress errors on the bare except. It's unlikely a try block contains code that can raise multiple ones.
try:
    ...
except (
    anyio.get_cancelled_exc_class()  # ASYNC103: 4, "anyio.get_cancelled_exc_class()"
):
    ...
except:  # safe ?
    ...

try:
    ...
except trio.Cancelled:  # ASYNC103: 7, "trio.Cancelled"
    ...
except:  # safe ?
    ...

try:
    ...
except (
    asyncio.exceptions.CancelledError  # ASYNC103: 4, "asyncio.exceptions.CancelledError"
):
    ...
except:  # safe ?
    ...

# Check we get the proper suggestion when all are imported
try:
    ...
except BaseException:  # ASYNC103_anyio_asyncio_trio: 7, "BaseException"
    ...

try:
    ...
except:  # ASYNC103_anyio_asyncio_trio: 0, "bare except"
    ...
