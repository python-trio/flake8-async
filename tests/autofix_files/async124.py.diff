---
+++
@@ x,6 x,7 @@
 # AUTOFIX
 # ASYNCIO_NO_AUTOFIX
 from typing import Any
+import trio


 def condition() -> bool:
@@ x,15 x,19 @@

 async def foo_print():  # ASYNC124: 0  # ASYNC910: 0, "exit", Statement("function definition", lineno)
     print("hello")
+    await trio.lowlevel.checkpoint()


 async def conditional_wait():  # ASYNC910: 0, "exit", Statement("function definition", lineno)
     if condition():
         await foo()
+    await trio.lowlevel.checkpoint()


 async def foo_gen():  # ASYNC124: 0  # ASYNC911: 0, "exit", Statement("yield", lineno+1)
+    await trio.lowlevel.checkpoint()
     yield  # ASYNC911: 4, "yield", Statement("function definition", lineno-1)
+    await trio.lowlevel.checkpoint()


 async def foo_async_with():
@@ x,11 x,13 @@
 async def foo_nested():  # ASYNC124: 0  # ASYNC910: 0, "exit", Statement("function definition", lineno)
     async def foo_nested_2():
         await foo()
+    await trio.lowlevel.checkpoint()


 async def foo_nested_sync():  # ASYNC124: 0  # ASYNC910: 0, "exit", Statement("function definition", lineno)
     def foo_nested_sync_child():
         await foo()  # type: ignore[await-not-async]
+    await trio.lowlevel.checkpoint()


 # We don't want to trigger on empty/pass functions because of inheritance.
@@ x,3 x,4 @@

 async def test_async_fixture(my_anyio_fixture):  # ASYNC124: 0  # ASYNC910: 0, "exit", Statement("function definition", lineno)
     assert my_anyio_fixture.setup_worked_correctly
+    await trio.lowlevel.checkpoint()
